@page
@using System.Data;
@model IntugentWebApp.Pages.Analysis.Analysis1Model
@{
    ViewData["ActivePage"] = "Mfg Analysis-1 Page";
}
@* Error Message *@
@if (TempData["ErrorOnServer"] != null)
{
    <div class="alert alert-danger alert-dismissible fade show" role="alert">
        Error: @TempData["ErrorOnServer"]
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
}
<div class="card card-default col-12">
    <div class="card-header align-items-center">
        <h2 class="">General Info</h2>
    </div>
    <div class="card-body">
        <div class="row align-items-center">
            <div class="row col-2 mx-2 px-3">
                <button type="button" onclick=gSearchDB() class="btn btn-primary btn-sm">Extract Data</button>
            </div>
            <div class="col-2">
                <!-- Mfg Site -->
                <div class="form-floating mb-2" onblur="">
                    <select id="gMfgSiteSelectedValue" class="form-select" id="MfgSite" onblur="">
                        @{
                            int rows = 0;
                        }
                        @foreach (DataRowView row in Model.gMfgSite)
                        {
                            <option value="@row["sLocation"]" selected="@(Model.gMfgSiteSelectedValue == row["sLocation"].ToString())">@row["sLocation"]</option>
                            rows++;
                        } 
                    </select>
                    <label for="gMfgSiteSelectedValue">Mfg Site</label>
                </div>
            </div>
            <div class="col-2">
                <!-- Production Code -->
                <div class="form-floating mb-2" onblur="">
                    <select class="form-select" id="ProdID" onblur="">
                           @foreach (DataRowView row in Model.gProd1)
                        {
                            <option value="@row["Product Code Global"]" selected="@(Model.gProd1SelectedValue == row["Product Code Global"].ToString())">@row["Product Code Global"]</option>
                        } 
                    </select>
                    <label for="ProdID">Production Code</label>
                </div>
            </div>
            <div class="col-1 mx-5">
                <p>Manufactured</p>
            </div>
            <div class="col-2">
                <!-- AfterDate -->
                <div class="form-floating mb-2">
                    <input id="gMfgDate1" type="datetime-local" class="form-control" id="AfterorAt" value="@Model.gMfgDate1?.ToString("yyyy-MM-ddThh:mm")" onblur="">
                    <label for="AfterorAt">After or At</label>
                </div>
            </div>
            <div class="col-2">
                <!-- BeforeDate -->
                <div class="form-floating mb-2">
                    <input id="gMfgDate2" type="datetime-local" class="form-control" id="BeforeorAt" value="@Model.gMfgDate2?.ToString("yyyy-MM-ddThh:mm")" onblur="">
                    <label for="BeforeorAt">Before or At</label>
                </div>
            </div>
        </div>

    </div>
</div>
<div class="row mt-5">
    <div class="col-8">
        @* gProp1 *@
        <div class="form-floating mb-2 mx-2" onblur="">
            <select class="form-select" id="gProp1" onchange="gProp1(this.options[this.selectedIndex].value)">
                @foreach (DataRowView row in Model.gProp1)
                {
                    <option value="@row["PropName"]" selected="@(Model.gProp1SelectedValue == row["PropName"].ToString())">@row["PropName"]</option>
                }
            </select>
            <label for="gProp1">Choose the Field to Display</label>
        </div>
    <canvas id="line-chart"></canvas>
    </div>
    <div class="col-4">
        @* Property/Correllation *@
        <div class="col-12">
                    <table class="table table-sm table-bordered table-hover table-striped table-responsive-md">
                        <thead class="thead-light">
                            <tr>
                                <th scope="col">Property</th>
                                <th scope="col">Correllation</th>
                            </tr>
                        </thead>
                        <tbody id="CorrTable">
                            @foreach (DataRowView row in Model.gCorr)
                            {

                                <tr>
                            <td>@row["PropName"]</td>
                            <td>@row["CorrValue"]</td>
                                </tr>

                            }
                        </tbody>
                    </table>
        </div>
    </div>
</div>
@section Scripts{
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            initializeChart(@Html.Raw(Json.Serialize(Model.XA)), @Html.Raw(Json.Serialize(Model.YA)), @Html.Raw(Json.Serialize(Model.XAvg1)), @Html.Raw(Json.Serialize(Model.YAvg1)), @Html.Raw(Json.Serialize(Model.YUCL1)), @Html.Raw(Json.Serialize(Model.YLCL1)));
        });

        function initializeChart(XA, YA, XAvg1, YAvg1, YUCL1, YLCL1) {
            const ctx = document.getElementById('line-chart').getContext('2d');

            const gLineA = {
                label: 'G Line A',
                data: XA.map((x, i) => ({ x, y: YA[i] })),
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 2,
                fill: false
            };

            const gPts1 = {
                label: 'gPts1',
                data: XA.map((x, i) => ({ x, y: YA[i] })),
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                fill: false
            };

            const gAvg = {
                label: 'gAvg',
                data: XAvg1.map((x, i) => ({ x, y: YAvg1[i] })),
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                fill: false
            };

            const gUCL = {
                label: 'gUCL',
                data: XAvg1.map((x, i) => ({ x, y: YUCL1[i] })),
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                fill: false
            };

            const gLCL = {
                label: 'gLCL',
                data: XAvg1.map((x, i) => ({ x, y: YLCL1[i] })),
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                fill: false
            };

            const config = {
                type: 'line',
                data: {
                    datasets: [gLineA, gPts1, gAvg, gUCL, gLCL]
                },
                options: {
                    pointRadius: 0,
                    responsive: true,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom'
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        },
                        zoom: {
                            zoom: {

                                wheel: {
                                    enabled: true,
                                },

                                drag: {
                                    enabled: true
                                }
                            },
                        }
                    }

                }

            };
            const myChart = new Chart(ctx, config);
            window.chart = myChart;
            let isPanning = false;
            let startX, startY;

            // Start panning
            ctx.canvas.addEventListener('mousedown', function (event) {
                isPanning = true;
                startX = event.clientX;
                startY = event.clientY;
            });

            // Handle panning movement
            ctx.canvas.addEventListener('mousemove', function (event) {
                if (isPanning) {
                    const diffX = startX - event.clientX;
                    const diffY = startY - event.clientY;

                    const xScale = myChart.scales.x;
                    const yScale = myChart.scales.y;


                    xScale.min += diffX * (xScale.max - xScale.min) / ctx.canvas.clientWidth;
                    xScale.max += diffX * (xScale.max - xScale.min) / ctx.canvas.clientWidth;

                    yScale.min -= diffY * (yScale.max - yScale.min) / ctx.canvas.clientHeight;
                    yScale.max -= diffY * (yScale.max - yScale.min) / ctx.canvas.clientHeight;


                    myChart.update('none');


                    startX = event.clientX;
                    startY = event.clientY;
                }
            });


            ctx.canvas.addEventListener('mouseup', function () {
                isPanning = false;
            });


            ctx.canvas.addEventListener('mouseleave', function () {
                isPanning = false;
            });
            document.getElementById('line-chart').addEventListener('dblclick', () => {
                myChart.resetZoom();
            });
        }

        function gProp1(value) {
            $.ajax({
                type: "POST",
                url: "/Analysis/Analysis1?handler=GProp1_Changed",
                headers: { "RequestVerificationToken": $('input[name="__RequestVerificationToken"]').val() },
                data: { value: value },
                success: function (response) {
                    console.log('Server response:', response);
                    updateUI(response);
                }
            });
        }

        function updateUI(response) {

            console.log('response.xa:', response.xa);
            console.log('response.ya:', response.ya);
            console.log('response.xAvg1:', response.xAvg1);
            console.log('response.yAvg1:', response.yAvg1);
            console.log('response.yucL1:', response.yucL1);
            console.log('response.ylcL1:', response.ylcL1);

            if (response.xa && response.ya && response.xAvg1 && response.yAvg1 && response.yucL1 && response.ylcL1) {
                window.chart.data.datasets[0].data = response.xa.map((x, i) => ({ x, y: response.ya[i] }));
                window.chart.data.datasets[1].data = response.xa.map((x, i) => ({ x, y: response.ya[i] }));
                window.chart.data.datasets[2].data = response.xAvg1.map((x, i) => ({ x, y: response.yAvg1[i] }));
                window.chart.data.datasets[3].data = response.xAvg1.map((x, i) => ({ x, y: response.yucL1[i] }));
                window.chart.data.datasets[4].data = response.xAvg1.map((x, i) => ({ x, y: response.ylcL1[i] }));

                window.chart.update();
            const correlationTableBody = document.getElementById('CorrTable');
            correlationTableBody.innerHTML = '';

            response.gCorr.forEach(row => {
                const newRow = correlationTableBody.insertRow();
                const propCell = newRow.insertCell(0);
                const corrCell = newRow.insertCell(1);

                propCell.textContent = row.propName;
                corrCell.textContent = row.corrValue;
            });
            }
            else {
                window.chart.data.datasets[0].data = [];
                window.chart.data.datasets[1].data = [];
                window.chart.data.datasets[2].data = [];
                window.chart.data.datasets[3].data = [];
                window.chart.data.datasets[4].data = [];
                window.chart.update();
                const correlationTableBody = document.getElementById('CorrTable');
                correlationTableBody.innerHTML = '';
                const newRow = correlationTableBody.insertRow();
                const propCell = newRow.insertCell(0);
                const corrCell = newRow.insertCell(1);

                propCell.textContent = '';  // Leave the propName cell empty
                corrCell.textContent = '';  // Leave the corrValue cell empty
                console.error("One or more properties are undefined in the response object.");
            }

        }
         function gSearchDB() {
            var gProp1SelectedValue = $('#gProp1').val();
            var gProd1SelectedValue = $('#ProdID').val();
            var gMfgSiteSelectedValue = $('#gMfgSiteSelectedValue').val();
            var gMfgDate1 = $('#gMfgDate1').val(); 
            var gMfgDate2 = $('#gMfgDate2').val();
            console.log(gProp1SelectedValue, gProd1SelectedValue, gMfgSiteSelectedValue, gMfgDate1, gMfgDate2);
            var form = $('#SearchParamsForm');

            $.ajax({
                type: "POST",
                url: "/Analysis/Analysis1?handler=GSearchDB_Click",
                headers: { "RequestVerificationToken": $('input[name="__RequestVerificationToken"]').val() },
                data: {
                    gProp1SelectedValue: gProp1SelectedValue,
                    gProd1SelectedValue: gProd1SelectedValue,
                    gMfgSiteSelectedValue: gMfgSiteSelectedValue,
                    gMfgDate1: gMfgDate1,
                    gMfgDate2: gMfgDate2,
                },
                success: function (response) {
                    console.log('Server response:', response);
                    updateUI(response);
                   // location.reload();
                },
                error: function (xhr, status, error) {
                    console.error('Error:', error);
                }
            });
        }
    </script>
}